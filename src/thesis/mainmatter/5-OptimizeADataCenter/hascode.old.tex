\section{Modelling ``Optimize a Data Center''} \label{section:data-center}


\subsection{Problem Description} \label{section:data-center-problem}


\subsection{Model} \label{section:data-center-model}

In this section, we will proceed to define the model for this problem.
Specifically,we begin by addressing key aspects such as the instance parameters
and the representation of this problem. Subsequently, we will delve into the
representation of solutions, the ground sets, and the components of this problem.
We will then present the objective function, giving particular attention to how
solutions are evaluated within the context of our chosen representation. We will
also explore the bounds established for this problem. Finally, we will discuss
the heuristics and heuristic rules that are utilized to construct solutions.

It should be noted that the effort of modeling will be formulated within the
context of the API for constructive search developed by
Outeiro~\cite{outeiro2021application}. As such, the modeling will be described
using the concepts and terminology specified in said work.

\subsubsection{Instance Parameters} \label{section:data-center-representation}

For the purpose of capturing the relevant information pertaining to the problem
at hand, we initiated the process by defining the \texttt{Problem} data
structure. This structure, in the context of modeling, encompasses the essential
attributes of the instance that are required for, among other things, the
construction of solutions. However, prior to specifying the data that was stored
for the problem, it is necessary to provide clarification regarding the terms
``segment'' and ``server''.

During the modeling phase, we identified that the rows of the data center could
not be considered as a sort of ``standard knapsack'', where placing a server
would simply encompass the consumption of available slots. This is because the
presence of unavailable slots in the row may prevent a server with a given size
from being placed. Thus, a row having sufficient space to accommodate a server
is not a sufficient requirement for its placement. Instead, we can view each row
of the data center as a collection of multiple knapsacks, where each group of
consecutive available slots is considered as a separate knapsack, which we refer
to as a segment.

From a modelling perspective, a segment can be then be described as a tuple
containing three defining fields. The first is the \textit{size}, which pertains
to the number of available slots. The second is the \textit{row}, which
obviously represent the row where that segment belongs. And last, the the
\textit{start}, which represents the starting slots (position) for the segment
in that rows since it useful in the solution construction.

Furthermore, as previously mentioned, a server has two properties: the
\textit{size} and the \textit{capacity}. From a modeling perspective, these are
the fields of a tuple that defines the server, with the added \textit{id} that
serves as an indexing reference in our representation.

Having defined the terminology, our solution structure is comprised of the
following fields:

\begin{itemize} \item \textbf{pools}: A numerical value indicating the quantity
        of resource pools to be created. \item \textbf{servers}: An list of servers to
        be allocated to segments and resource pools. \item \textbf{sorted (servers)}: A
        list containing, indexes of the servers sorted by an heuristic (ratio between
        the size and capacity of the server). This is used in the solution-building
        process. \item \textbf{segments}: An list of segments within the data center, to
        be populated with servers. \item \textbf{rows}: An list of sets, each of which
        records the segments associated each row. \end{itemize}

\subsubsection{Decision Space} \label{section:data-center-decision-space}

Having defined the problem the next step in the modelling process is to define
the decision space. Namely the components and the solutions.

Given that the objective of this problem is to construct a data center layout
by positioning servers in rows and assigning them to resource pools, it can be
inferred that a solution will consist of a list of objects (components) that
record this information. As such the component structure for this problem can be
defined as follows by the following properties.

\begin{itemize} \item \textbf{server}: The index (as represented in the
        "servers" list) of the selected server. \item \textbf{segment}: The index (as
        represented in the "segments" list) of the segment where the selected server
        will be placed. \item \textbf{pool}: The resource pool to which the selected
        server is to be assigned. \end{itemize}

Thus, the ground set $\mathcal{G}$ of the problem becomes defined as the set
containing tuples that represent all possible combinations of these properties.

In regards to the representation of solutions, it is important to note that in
this problem, a partial solution, which is defined as a solution in which not
all available servers have been assigned, is a feasible solution that can be
properly evaluated through the objective function. With that in mind, the model
represents solutions as structures containing the following properties:

\begin{itemize} \item \textbf{score}: The value resulting from the evaluation
        of this solution through the objective function. \item \textbf{allocation}: A
        list of components mapping a server to a given pool and segment. \item
        \textbf{gc}: A list containing the guaranteed capacities of each resource pool.
  \item \textbf{capacity}: A matrix containing the capacities of each resource
        pool for each row of the data center. \item \textbf{sc}: The remaining space in
        each segment. \end{itemize}

Additional properties, such as iterators and collections containing items
ordered by multiple criteria, are also stored in the solution. This is done in
order to maintain the state of the solution and to cache results from previous
computations, thereby improving performance. However, these properties are not
included in the present discussion, as they are not essential for a proper
understanding of the modeling process and are considered to be implementation
details.

\subsubsection{Objective Function} \label{section:
  data-center-objective-function}

As previously discussed in Section~\ref{section:data-center-problem}, the
objective function for this problem can be calculated in a similar fashion by
determining the minimum value within the range of values contained in the list
designated as ``\textit{gc}''. The method of constructing the solutions ensures
that this list is continuously updated throughout the construction process.
However, if the solution remains unmodified, the objective function value for a
given solution can be accessed efficiently through the "score" attribute defined
in the solution's model.

\subsubsection{Bound} \label{section:data-center-bound}

In contrast to the objective function, which serves as a metric for the quality
of a solution within a given context, the bounds provide insight into the
potential of a solution in the future.

In the context of this problem, where the objective is to address a bottleneck
(objective function), it is intuitive that achieving optimal solutions requires
distributing the servers for a given pool as evenly as possible across the rows
of the server. This is because in the event of a failure, it would be
detrimental if all the servers for a pool were located in the same row that
failed. Therefore, this factor was taken into consideration when formulating the
bounds.

Additionally, certain relaxations were made to the constraints of the problem
when calculating the bound. Specifically, the bound disregards the requirement
that the servers must fit within the total space available in the segments, and
only takes into account the available space in the slots for each row and the
size of the server to be placed.

Taking this into account, the upper bound for this model can be calculated in
two steps:

% Prove that this bound works (TODO) \begin{enumerate} \item \textbf{Row-Wise
Bound} \\ Let, \begin{itemize} \item $\Theta_{\mathcal{R} \setminus r}$: Denote
        the remaining empty space in all the rows in the data center but the row $r$.
  \item $\sum_{\Theta_{\mathcal{R} \setminus r}}$: Denote the maximum sum of the
        capacities of the available servers that can be fractionally placed into
        $\Theta_{\mathcal{R} \setminus r}$ w.r.t to the ratio between the capacity and
        the size of the server. This related to with a classical upper bound for the
        multiple-knapsack problem~\cite{martello1981bound}. \end{itemize} Then, The
row-wise upper bound is expressed by: \begin{equation} \Phi_{ub}^{r} =
  \frac{\sum_{\Theta_{\mathcal{R} \setminus r}}}{\mathcal{P}} \end{equation} \item
\textbf{Upper bound}\\ The upper bound for a given solution $s$ can then be
calculated as: \begin{equation} \Phi_{ub}(s) = \min_{r \in \mathcal{R}}
  \Phi_{ub}^{r} \end{equation} \end{enumerate}

Furthermore, we can apply a correction to tighten each row-wise upper bound by
discarding pools and servers that already have a guaranteed capacity, when
dropping that row, greater than the value of the row-wise upper bound. After
discarding them, we can recompute the bound for a reduced server set and number
of pools. We repeat this process until no further correction can be applied, i.e.
until no considered pool has a guaranteed capacity greater than the bound.

\subsubsection{Construction Rules} \label{section:
  data-center-construction-rules}

Having identified and defined all of the necessary elementary components of the
model, the next step is to establish the methodology for integrating these
components into functional solutions. To accomplish this, there are certain key
concepts that must be addressed, such as enumeration and assignment/removal.

In the proposed model, enumeration is achieved through the utilization of the
\textit{enumMove} and \textit{heuristicMoveWOR} operations. These operations
function similar to iterators, continuously providing components that could be
added to a solution. The specific order in which these components are presented,
for each operation within the context of this model, is defined as follows:

\begin{itemize} \item \textbf{{\textit{enumMove}}}\\ This operation allows for
        the enumeration of all feasible components in the context of this problem. A
        feasible component could be interpreted as a component that can be added to a
        solution without violating the constraints that in this case are related to the
        available space for the placement of server given that there are no restrictions
        with respect to the assignment to resource pools.

  \item \textbf{{\textit{heuristicMoveWOR}}}\\ The operation in question enables
        the sequential enumeration of all components in a specific order, determined by
        a heuristic. This order is consistent with that specified in the
        \textit{heuristicMove} function, which enables the selection of components to be
        added based on a predefined heuristic criterion. Additionally, when a component
        is yielded during the iteration, it is no longer eligible for further
        consideration, hence the inclusion of ``WOR'' in the operation name, indicating
        that the enumeration is conducted ``without replacement''.

        The heuristic employed in this model can be succinctly characterized as a
        strategy in which the server with the most favorable capacity-to-size ratio is
        assigned to the pool with the least guaranteed capacity in the row that
        possesses the highest available space. \end{itemize}

In regards to the assignment and removal of components to and from solutions,
this is accomplished through the implementation of the \textit{applyMove}
operation. In the context of this model, the addition of a component to a
solution, denoted as ``ADD'`, involves decreasing the available space within the
segment (referred to as \textit{sc}) in which the server is placed by the size
of the server, and updating the guaranteed capacity of the associated pool
(referred to as \textit{gc} and \textit{capacity}) to reflect the inclusion of
the server. Conversely, the removal of a component, denoted as ``REMOVE'',
follows a similar process but in the opposite direction, returning the capacity
to the segment from which it was originally allocated.

\subsection{Results} \label{section:data-center-results}

From a practical perspective, the limited availability of instances for testing
was a limitation of our work. However, we were able to achieve a score of 386
points on the instance that was available, which places us at 25th in the
classification table. This was achieved without using a local search approach
and with minimal fine-tuning of the algorithms.

In fact, the algorithm used was a simple testing utility that, during the
solution construction process, enumerates the $n$ best component insertions
(moves) in a heuristic manner, and selects and stores the best one based on the
calculated value of the bound. This utility can be considered general with
respect to the model, as it was implemented in adherence to the principles of
modeling. For clarity, the pseudo-code in Algorithm~\ref{algorithm:
  enum-best-heuristic} illustrates its operation.

\begin{algorithm}[htb!] \DontPrintSemicolon \caption{Narrow Guided Heuristic
    Construction} \label{algorithm:enum-best-heuristic} \KwIn{Problem Instance
    ($\mathcal{P}$), Limit (${N}$)} \KwOut{Best solution found ($s^{*}$).} \Begin{
    $s^{*} \gets \emptyset$\; \While{True}{ \normalfont{updated} $\gets False$\;
      $s^{\prime} \gets s^{*}$\; $c^{*} \gets \emptyset$\; \For{$i = 0$
        \normalfont{to} $N$}{ $c^{\prime} \gets $ \normalfont{HeuristicMoveWOR($s^{*}$,
          \textbf{\normalfont{ADD})}}\; \normalfont{ApplyMove($c^{\prime}$, $s^{\prime}$,
          \textbf{\normalfont{ADD}})}\; \If{$\Phi_{ub}(s^{\prime})$ > $\Phi_{ub}(s^{*}$)}{
          $c^{*} \gets c^{\prime}$\; \normalfont{updated} $ \gets True$\; }
        \normalfont{ApplyMove($c^{\prime}$, $s^{\prime}$,
          \textbf{\normalfont{REMOVE})}}\; } \If{$\lnot$ \normalfont{updated}}{
        \Return{$s^{*}$}; } \normalfont{ApplyMove($c^{*}$, $s^{*}$,
        \textbf{\normalfont{ADD}}))}\; } } \end{algorithm}

\section{Concluding Remarks} \label{section:data-center-remarks}

In this chapter, we presented the preliminary work developed during this
semester. We began by conducting an initial survey of the Hash Code problems,
and categorizing them from a modeling perspective. This survey will be completed
in the near future. From this survey, the "Modelling a data center problem" was
selected and modeled in a principled fashion.

In general, we achieved decent results. However, it is worth noting that the
limited number of available instances presented a challenge for both testing and
verifying our results. Additionally, the competition being restricted to a
specific region (Paris) resulted in a lower number of participants attempting
the problem than we had anticipated. Furthermore, our research yielded few
references or solutions from other sources that could provide insight into
achieving better scores, likely due to the problem being relatively old.

Given the limited availability of instances for testing, it was suggested
during a discussion to explore the use of an exact method for solving this
problem and comparing the results to our approach. The problem as defined in
section~\ref{section:data-center-problem} has relatively small constraints,
which may allow for the generation of instances that can be solved by an exact
method within a feasible amount of time. It would be informative to compare the
results obtained by the exact method with our approach, in order to determine
the quality of the solution reached through our methodology.

Lastly, it is worth noting that the results obtained for the analyzed instance
can be further optimized. This is an objective that we aim to achieve in the
upcoming semester.