Combinatorial optimization literature extensively documents a series of methods
for solving multiple
problems~\cite{papadimitriou1998combinatorial,yu2010combinatorial,luke2013essentialsa}.
The approaches followed by these methods are diverse and typically defined by
factors such as the time complexity, the quality and the strategy for finding
solutions. Particularly, algorithms are often classified in the literature as
exact, approximation, or heuristic based on the quality of solutions. Moreover,
for each category exist procedures with varying complexities rely on different
strategies to find solutions which, in essence, can be classified as
constructive or local.

\subsection{Exact, Approximation and Heuristic Methods}
\label{subsec:approaches}

\emph{Exact} methods are designed to find the optimal solution for a given
problem. These typically involve an exhaustive enumeration and evaluation of
solutions. However, in large problem instances, this may prove to be
computationally infeasible.~In the context
of~\acrshort{combinatorial-optimization} problems, two general exact algorithms
are well-known and widely studied:~\textit{Branch and Bound} and~\textit{Dynamic
  Programming}~\cite{clausenbranch,festa2014brief}.

These algorithms operate by iteratively breaking down a problem into smaller,
interconnected or standalone sub-problems. The solutions to these are then
combined to form the final solution. However, each algorithm employs distinct
techniques to enhance the exploration of the search space.

In Branch and Bound approaches, the strategy revolves around utilizing bounds to
restrict the search space. Specifically, the upper bound facilitates pruning the
search tree, effectively eliminating the need to explore solutions that are
undoubtedly worse with respect to best solution found by the algorithm at a
particular stage. Similarly, the lower bound guarantees that solutions of
inferior quality are rejected during the search process. On the other hand,
Dynamic Programming approaches leverage the optimal substructure
property~\cite{festa2014brief}, thereby avoiding recomputing previous
sub-problems.

\emph{Approximation} methods are designed to find solutions that are provably
guaranteed to be close to the optimal quality with respect to a given
approximation factor. In fact, approximation methods are often able to solve
problems in polynomial time and yield solutions of relatively high
quality~\cite{williamson2011design}.  However, it is important to note that
they require a mathematical proof of approximation that is specific to the
problem at hand. Notably, a significant amount of research exists in this field
concerning~\acrshort{combinatorial-optimization}
problems~\cite{johnson1974approximation}.

\emph{Heuristic} methods work by finding solutions according to a general
\textquote{rule of thumb}, the quality of which can be verified through
experimentation. These methods do not provide any guarantees of optimality, as
they are derived from intuition and their effectiveness is closely tied to the
characteristics of the problem at hand. Nevertheless, they are reliable means of
finding solutions in difficult~\acrshort{combinatorial-optimization} problems. A
well-known class of algorithms that further extends these methods are meta-heuristics
as will be further discussed.

\subsection{Constructive Search}
\label{subsec:contructive-search}

\acrfull{constructive-search} is an approach for optimization where from an
empty or partial solution for a given problem a feasible complete solution is
constructed by iteratively adding components extracted from the ground set. The
construction process is guided by a pre-established set of rules, which may be
heuristic in nature or informed by other relevant information,~\eg{}, objective
value and bounds.~These rules determine what components from the ground set can
be included in the solution at each iteration. The construction stops when no
more components can be added to the solution,~\ie{}, the solution is complete.

A generic pseudo code for a~\acrshort{constructive-search}
procedure~\cite{marti2013multistart} is shown in~\Cref{algorithm:cs}.

\begin{algorithm}
  \DontPrintSemicolon
  \input{mainmatter/2-Background/algorithms/cs.tex}
  \caption{Constructive Procedure}
  \label{algorithm:cs}
\end{algorithm}

It's important to observe that a constructive search approach hinges on a
strategy for choosing a component to add to a solution. This process is
represented in~\Cref{algorithm:cs} through the~\texttt{SelectComponent}
function. Additionally, a multitude of problem-specific information is at play,
encompassing tasks like generating an empty solution,assessing the feasibility,
enumerating components, and adding components. These elements directly influence
the constructive search procedures as will be detailed further.

\subsection{Local Search}
\label{subsec:local-search}

\acrfull{local-search} approaches with, begin feasible solution to a given
problem, and then make modifications by adding or removing components in order
to improve it. These transformations, are typically localized and aim to exploit
the solution's neighborhood, as defined by the neighborhood structure of the
problem. The procedure concludes when no further alterations can enhance the
solution's quality, ultimately leading to a local optimum.

Although the primary objective of~\acrshort{local-search} is to improve a
solution in the direction of finding a local optimum. However, it is common for
such a~\acrshort{local-search} approach to intentionally worsen a solution in
order to allow for further exploration of previously unseen regions of the
search space. This action commonly referred to as
a~\textit{perturbation}~\cite{lourenco2010iterateda}. Furthermore, this
approach is frequently applied in sequence to a constructive search phase, where
a~\acrshort{constructive-search} algorithm is used to construct a good initial
solution, which is then further improved by a local search approach.