In this chapter, we a proposed framework for problem modeling that enables the
development of solvers capable of addressing problems in a black-box manner.
While we used our \emph{Python} implementation to illustrate the framework from
a modeling, solver development, and testing perspective, the fundamental
constructs of this framework can be extrapolated and applied to any programming
language. Our intent was to demonstrate the general principles that underlie the
framework. We applied this implementation of the framework to model two specific
problems in the Google Hash Code competition, which we will discuss
in~\Cref{ch:optimize-data-center,ch:book-scanning}.

The selection of~\emph{Python} as our programming language, for developing the
framework and models, was primarily driven by its ease of use, rapid prototyping
capabilities, and rich high-level features. However, the language interpreted
nature and relative slowness compared to compiled languages can impact the
efficiency of solver execution.~To mitigate this, we turned to an alternative
\emph{Python} implementation known as~\emph{PyPy}.~This just-in-time (JIT) compiled
version of Python has a substantial speed boost, claiming to be approximately
4.8 times faster than the on found and average interpreter~(\emph{CPython}).

% TODO: Add a plot here to prove it

The decision to employ~\emph{PyPy} proved crucial, as it significantly improved the
execution times of our solvers.~This was particularly evident when dealing with
complex problem instances, where the performance difference was remarkable.
Albeit, while the current~\emph{Python} implementation served its purpose for
prototyping and exploring ideas for problem-solving, a reimplemented version of
this framework in a more performant programming language would be necessary for
optimal performance. Nonetheless, for brainstorming and rapidly testing new
ideas from a modeling standpoint, from our perspective, this framework remains
a valuable choice.